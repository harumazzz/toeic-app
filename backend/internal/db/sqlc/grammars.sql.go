// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: grammars.sql

package db

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/lib/pq"
)

const batchGetGrammars = `-- name: BatchGetGrammars :many
SELECT id, level, title, tag, grammar_key, related, contents FROM grammars
WHERE id = ANY($1::int[])
ORDER BY id
`

func (q *Queries) BatchGetGrammars(ctx context.Context, dollar_1 []int32) ([]Grammar, error) {
	rows, err := q.db.QueryContext(ctx, batchGetGrammars, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Grammar
	for rows.Next() {
		var i Grammar
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Title,
			pq.Array(&i.Tag),
			&i.GrammarKey,
			pq.Array(&i.Related),
			&i.Contents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createGrammar = `-- name: CreateGrammar :one
INSERT INTO grammars (
    level,
    title,
    tag,
    grammar_key,
    related,
    contents
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, level, title, tag, grammar_key, related, contents
`

type CreateGrammarParams struct {
	Level      int32           `json:"level"`
	Title      string          `json:"title"`
	Tag        []string        `json:"tag"`
	GrammarKey string          `json:"grammar_key"`
	Related    []int32         `json:"related"`
	Contents   json.RawMessage `json:"contents"`
}

func (q *Queries) CreateGrammar(ctx context.Context, arg CreateGrammarParams) (Grammar, error) {
	row := q.db.QueryRowContext(ctx, createGrammar,
		arg.Level,
		arg.Title,
		pq.Array(arg.Tag),
		arg.GrammarKey,
		pq.Array(arg.Related),
		arg.Contents,
	)
	var i Grammar
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Title,
		pq.Array(&i.Tag),
		&i.GrammarKey,
		pq.Array(&i.Related),
		&i.Contents,
	)
	return i, err
}

const deleteGrammar = `-- name: DeleteGrammar :exec
DELETE FROM grammars
WHERE id = $1
`

func (q *Queries) DeleteGrammar(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteGrammar, id)
	return err
}

const getGrammar = `-- name: GetGrammar :one
SELECT id, level, title, tag, grammar_key, related, contents FROM grammars
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetGrammar(ctx context.Context, id int32) (Grammar, error) {
	row := q.db.QueryRowContext(ctx, getGrammar, id)
	var i Grammar
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Title,
		pq.Array(&i.Tag),
		&i.GrammarKey,
		pq.Array(&i.Related),
		&i.Contents,
	)
	return i, err
}

const getRandomGrammar = `-- name: GetRandomGrammar :one
SELECT id, level, title, tag, grammar_key, related, contents FROM grammars
ORDER BY RANDOM()
LIMIT 1
`

func (q *Queries) GetRandomGrammar(ctx context.Context) (Grammar, error) {
	row := q.db.QueryRowContext(ctx, getRandomGrammar)
	var i Grammar
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Title,
		pq.Array(&i.Tag),
		&i.GrammarKey,
		pq.Array(&i.Related),
		&i.Contents,
	)
	return i, err
}

const listGrammars = `-- name: ListGrammars :many
SELECT id, level, title, tag, grammar_key, related, contents FROM grammars
ORDER BY id
LIMIT $1
OFFSET $2
`

type ListGrammarsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListGrammars(ctx context.Context, arg ListGrammarsParams) ([]Grammar, error) {
	rows, err := q.db.QueryContext(ctx, listGrammars, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Grammar
	for rows.Next() {
		var i Grammar
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Title,
			pq.Array(&i.Tag),
			&i.GrammarKey,
			pq.Array(&i.Related),
			&i.Contents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGrammarsByLevel = `-- name: ListGrammarsByLevel :many
SELECT id, level, title, tag, grammar_key, related, contents FROM grammars
WHERE level = $1
ORDER BY id
LIMIT $2
OFFSET $3
`

type ListGrammarsByLevelParams struct {
	Level  int32 `json:"level"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListGrammarsByLevel(ctx context.Context, arg ListGrammarsByLevelParams) ([]Grammar, error) {
	rows, err := q.db.QueryContext(ctx, listGrammarsByLevel, arg.Level, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Grammar
	for rows.Next() {
		var i Grammar
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Title,
			pq.Array(&i.Tag),
			&i.GrammarKey,
			pq.Array(&i.Related),
			&i.Contents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGrammarsByTag = `-- name: ListGrammarsByTag :many
SELECT id, level, title, tag, grammar_key, related, contents FROM grammars
WHERE $1 = ANY(tag)
ORDER BY level, id
LIMIT $2
OFFSET $3
`

type ListGrammarsByTagParams struct {
	Tag    []string `json:"tag"`
	Limit  int32    `json:"limit"`
	Offset int32    `json:"offset"`
}

func (q *Queries) ListGrammarsByTag(ctx context.Context, arg ListGrammarsByTagParams) ([]Grammar, error) {
	rows, err := q.db.QueryContext(ctx, listGrammarsByTag, pq.Array(arg.Tag), arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Grammar
	for rows.Next() {
		var i Grammar
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Title,
			pq.Array(&i.Tag),
			&i.GrammarKey,
			pq.Array(&i.Related),
			&i.Contents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchGrammars = `-- name: SearchGrammars :many
SELECT id, level, title, tag, grammar_key, related, contents FROM grammars
WHERE
    title ILIKE '%' || $1 || '%' OR
    grammar_key ILIKE '%' || $1 || '%' OR
    EXISTS (SELECT 1 FROM unnest(tag) AS t WHERE t ILIKE '%' || $1 || '%')
ORDER BY level, id
LIMIT $2
OFFSET $3
`

type SearchGrammarsParams struct {
	Column1 sql.NullString `json:"column_1"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) SearchGrammars(ctx context.Context, arg SearchGrammarsParams) ([]Grammar, error) {
	rows, err := q.db.QueryContext(ctx, searchGrammars, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Grammar
	for rows.Next() {
		var i Grammar
		if err := rows.Scan(
			&i.ID,
			&i.Level,
			&i.Title,
			pq.Array(&i.Tag),
			&i.GrammarKey,
			pq.Array(&i.Related),
			&i.Contents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGrammar = `-- name: UpdateGrammar :one
UPDATE grammars
SET
    level = $2,
    title = $3,
    tag = $4,
    grammar_key = $5,
    related = $6,
    contents = $7
WHERE id = $1
RETURNING id, level, title, tag, grammar_key, related, contents
`

type UpdateGrammarParams struct {
	ID         int32           `json:"id"`
	Level      int32           `json:"level"`
	Title      string          `json:"title"`
	Tag        []string        `json:"tag"`
	GrammarKey string          `json:"grammar_key"`
	Related    []int32         `json:"related"`
	Contents   json.RawMessage `json:"contents"`
}

func (q *Queries) UpdateGrammar(ctx context.Context, arg UpdateGrammarParams) (Grammar, error) {
	row := q.db.QueryRowContext(ctx, updateGrammar,
		arg.ID,
		arg.Level,
		arg.Title,
		pq.Array(arg.Tag),
		arg.GrammarKey,
		pq.Array(arg.Related),
		arg.Contents,
	)
	var i Grammar
	err := row.Scan(
		&i.ID,
		&i.Level,
		&i.Title,
		pq.Array(&i.Tag),
		&i.GrammarKey,
		pq.Array(&i.Related),
		&i.Contents,
	)
	return i, err
}
