// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_answers.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
)

const countCorrectAnswersByAttempt = `-- name: CountCorrectAnswersByAttempt :one
SELECT COUNT(*) FROM user_answers
WHERE attempt_id = $1 AND is_correct = true
`

func (q *Queries) CountCorrectAnswersByAttempt(ctx context.Context, attemptID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countCorrectAnswersByAttempt, attemptID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserAnswersByAttempt = `-- name: CountUserAnswersByAttempt :one
SELECT COUNT(*) FROM user_answers
WHERE attempt_id = $1
`

func (q *Queries) CountUserAnswersByAttempt(ctx context.Context, attemptID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserAnswersByAttempt, attemptID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUserAnswer = `-- name: CreateUserAnswer :one
INSERT INTO user_answers (
    attempt_id,
    question_id,
    selected_answer,
    is_correct,
    answer_time
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING user_answer_id, attempt_id, question_id, selected_answer, is_correct, answer_time, created_at
`

type CreateUserAnswerParams struct {
	AttemptID      int32        `json:"attempt_id"`
	QuestionID     int32        `json:"question_id"`
	SelectedAnswer string       `json:"selected_answer"`
	IsCorrect      bool         `json:"is_correct"`
	AnswerTime     sql.NullTime `json:"answer_time"`
}

func (q *Queries) CreateUserAnswer(ctx context.Context, arg CreateUserAnswerParams) (UserAnswer, error) {
	row := q.db.QueryRowContext(ctx, createUserAnswer,
		arg.AttemptID,
		arg.QuestionID,
		arg.SelectedAnswer,
		arg.IsCorrect,
		arg.AnswerTime,
	)
	var i UserAnswer
	err := row.Scan(
		&i.UserAnswerID,
		&i.AttemptID,
		&i.QuestionID,
		&i.SelectedAnswer,
		&i.IsCorrect,
		&i.AnswerTime,
		&i.CreatedAt,
	)
	return i, err
}

const deleteUserAnswer = `-- name: DeleteUserAnswer :exec
DELETE FROM user_answers
WHERE user_answer_id = $1
`

func (q *Queries) DeleteUserAnswer(ctx context.Context, userAnswerID int32) error {
	_, err := q.db.ExecContext(ctx, deleteUserAnswer, userAnswerID)
	return err
}

const deleteUserAnswersByAttempt = `-- name: DeleteUserAnswersByAttempt :exec
DELETE FROM user_answers
WHERE attempt_id = $1
`

func (q *Queries) DeleteUserAnswersByAttempt(ctx context.Context, attemptID int32) error {
	_, err := q.db.ExecContext(ctx, deleteUserAnswersByAttempt, attemptID)
	return err
}

const getAttemptScore = `-- name: GetAttemptScore :one
SELECT 
    COUNT(*) as total_questions,
    COUNT(CASE WHEN is_correct = true THEN 1 END) as correct_answers,
    ROUND(
        (COUNT(CASE WHEN is_correct = true THEN 1 END)::numeric / COUNT(*)::numeric) * 990, 2
    ) as calculated_score
FROM user_answers
WHERE attempt_id = $1
`

type GetAttemptScoreRow struct {
	TotalQuestions  int64  `json:"total_questions"`
	CorrectAnswers  int64  `json:"correct_answers"`
	CalculatedScore string `json:"calculated_score"`
}

func (q *Queries) GetAttemptScore(ctx context.Context, attemptID int32) (GetAttemptScoreRow, error) {
	row := q.db.QueryRowContext(ctx, getAttemptScore, attemptID)
	var i GetAttemptScoreRow
	err := row.Scan(&i.TotalQuestions, &i.CorrectAnswers, &i.CalculatedScore)
	return i, err
}

const getQuestionAnalytics = `-- name: GetQuestionAnalytics :many
SELECT 
    q.question_id,
    q.title,
    COUNT(ua.user_answer_id) as total_attempts,
    COUNT(CASE WHEN ua.is_correct = true THEN 1 END) as correct_attempts,
    ROUND(
        (COUNT(CASE WHEN ua.is_correct = true THEN 1 END)::numeric / COUNT(ua.user_answer_id)::numeric) * 100, 2
    ) as success_rate
FROM questions q
LEFT JOIN user_answers ua ON q.question_id = ua.question_id
WHERE q.content_id IN (
    SELECT c.content_id FROM contents c
    JOIN parts p ON c.part_id = p.part_id
    WHERE p.exam_id = $1
)
GROUP BY q.question_id, q.title
ORDER BY success_rate ASC
`

type GetQuestionAnalyticsRow struct {
	QuestionID      int32  `json:"question_id"`
	Title           string `json:"title"`
	TotalAttempts   int64  `json:"total_attempts"`
	CorrectAttempts int64  `json:"correct_attempts"`
	SuccessRate     string `json:"success_rate"`
}

func (q *Queries) GetQuestionAnalytics(ctx context.Context, examID int32) ([]GetQuestionAnalyticsRow, error) {
	rows, err := q.db.QueryContext(ctx, getQuestionAnalytics, examID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetQuestionAnalyticsRow
	for rows.Next() {
		var i GetQuestionAnalyticsRow
		if err := rows.Scan(
			&i.QuestionID,
			&i.Title,
			&i.TotalAttempts,
			&i.CorrectAttempts,
			&i.SuccessRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserAnswer = `-- name: GetUserAnswer :one
SELECT user_answer_id, attempt_id, question_id, selected_answer, is_correct, answer_time, created_at FROM user_answers
WHERE user_answer_id = $1 LIMIT 1
`

func (q *Queries) GetUserAnswer(ctx context.Context, userAnswerID int32) (UserAnswer, error) {
	row := q.db.QueryRowContext(ctx, getUserAnswer, userAnswerID)
	var i UserAnswer
	err := row.Scan(
		&i.UserAnswerID,
		&i.AttemptID,
		&i.QuestionID,
		&i.SelectedAnswer,
		&i.IsCorrect,
		&i.AnswerTime,
		&i.CreatedAt,
	)
	return i, err
}

const getUserAnswerByAttemptAndQuestion = `-- name: GetUserAnswerByAttemptAndQuestion :one
SELECT user_answer_id, attempt_id, question_id, selected_answer, is_correct, answer_time, created_at FROM user_answers
WHERE attempt_id = $1 AND question_id = $2 LIMIT 1
`

type GetUserAnswerByAttemptAndQuestionParams struct {
	AttemptID  int32 `json:"attempt_id"`
	QuestionID int32 `json:"question_id"`
}

func (q *Queries) GetUserAnswerByAttemptAndQuestion(ctx context.Context, arg GetUserAnswerByAttemptAndQuestionParams) (UserAnswer, error) {
	row := q.db.QueryRowContext(ctx, getUserAnswerByAttemptAndQuestion, arg.AttemptID, arg.QuestionID)
	var i UserAnswer
	err := row.Scan(
		&i.UserAnswerID,
		&i.AttemptID,
		&i.QuestionID,
		&i.SelectedAnswer,
		&i.IsCorrect,
		&i.AnswerTime,
		&i.CreatedAt,
	)
	return i, err
}

const getUserAnswerHistory = `-- name: GetUserAnswerHistory :many
SELECT 
    ua.user_answer_id, ua.attempt_id, ua.question_id, ua.selected_answer, ua.is_correct, ua.answer_time, ua.created_at,
    q.title as question_title,
    q.true_answer,
    ea.exam_id,
    e.title as exam_title
FROM user_answers ua
JOIN exam_attempts ea ON ua.attempt_id = ea.attempt_id
JOIN questions q ON ua.question_id = q.question_id
JOIN contents c ON q.content_id = c.content_id
JOIN parts p ON c.part_id = p.part_id
JOIN exams e ON p.exam_id = e.exam_id
WHERE ea.user_id = $1
ORDER BY ua.answer_time DESC
LIMIT $2 OFFSET $3
`

type GetUserAnswerHistoryParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetUserAnswerHistoryRow struct {
	UserAnswerID   int32        `json:"user_answer_id"`
	AttemptID      int32        `json:"attempt_id"`
	QuestionID     int32        `json:"question_id"`
	SelectedAnswer string       `json:"selected_answer"`
	IsCorrect      bool         `json:"is_correct"`
	AnswerTime     sql.NullTime `json:"answer_time"`
	CreatedAt      time.Time    `json:"created_at"`
	QuestionTitle  string       `json:"question_title"`
	TrueAnswer     string       `json:"true_answer"`
	ExamID         int32        `json:"exam_id"`
	ExamTitle      string       `json:"exam_title"`
}

func (q *Queries) GetUserAnswerHistory(ctx context.Context, arg GetUserAnswerHistoryParams) ([]GetUserAnswerHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserAnswerHistory, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserAnswerHistoryRow
	for rows.Next() {
		var i GetUserAnswerHistoryRow
		if err := rows.Scan(
			&i.UserAnswerID,
			&i.AttemptID,
			&i.QuestionID,
			&i.SelectedAnswer,
			&i.IsCorrect,
			&i.AnswerTime,
			&i.CreatedAt,
			&i.QuestionTitle,
			&i.TrueAnswer,
			&i.ExamID,
			&i.ExamTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAnswersByAttempt = `-- name: ListUserAnswersByAttempt :many
SELECT user_answer_id, attempt_id, question_id, selected_answer, is_correct, answer_time, created_at FROM user_answers
WHERE attempt_id = $1
ORDER BY answer_time
`

func (q *Queries) ListUserAnswersByAttempt(ctx context.Context, attemptID int32) ([]UserAnswer, error) {
	rows, err := q.db.QueryContext(ctx, listUserAnswersByAttempt, attemptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserAnswer
	for rows.Next() {
		var i UserAnswer
		if err := rows.Scan(
			&i.UserAnswerID,
			&i.AttemptID,
			&i.QuestionID,
			&i.SelectedAnswer,
			&i.IsCorrect,
			&i.AnswerTime,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserAnswersByAttemptWithQuestions = `-- name: ListUserAnswersByAttemptWithQuestions :many
SELECT 
    ua.user_answer_id, ua.attempt_id, ua.question_id, ua.selected_answer, ua.is_correct, ua.answer_time, ua.created_at,
    q.title as question_title,
    q.true_answer,
    q.explanation,
    q.possible_answers
FROM user_answers ua
JOIN questions q ON ua.question_id = q.question_id
WHERE ua.attempt_id = $1
ORDER BY ua.answer_time
`

type ListUserAnswersByAttemptWithQuestionsRow struct {
	UserAnswerID    int32        `json:"user_answer_id"`
	AttemptID       int32        `json:"attempt_id"`
	QuestionID      int32        `json:"question_id"`
	SelectedAnswer  string       `json:"selected_answer"`
	IsCorrect       bool         `json:"is_correct"`
	AnswerTime      sql.NullTime `json:"answer_time"`
	CreatedAt       time.Time    `json:"created_at"`
	QuestionTitle   string       `json:"question_title"`
	TrueAnswer      string       `json:"true_answer"`
	Explanation     string       `json:"explanation"`
	PossibleAnswers []string     `json:"possible_answers"`
}

func (q *Queries) ListUserAnswersByAttemptWithQuestions(ctx context.Context, attemptID int32) ([]ListUserAnswersByAttemptWithQuestionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserAnswersByAttemptWithQuestions, attemptID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserAnswersByAttemptWithQuestionsRow
	for rows.Next() {
		var i ListUserAnswersByAttemptWithQuestionsRow
		if err := rows.Scan(
			&i.UserAnswerID,
			&i.AttemptID,
			&i.QuestionID,
			&i.SelectedAnswer,
			&i.IsCorrect,
			&i.AnswerTime,
			&i.CreatedAt,
			&i.QuestionTitle,
			&i.TrueAnswer,
			&i.Explanation,
			pq.Array(&i.PossibleAnswers),
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserAnswer = `-- name: UpdateUserAnswer :one
UPDATE user_answers
SET 
    selected_answer = $2,
    is_correct = $3,
    answer_time = NOW()
WHERE user_answer_id = $1
RETURNING user_answer_id, attempt_id, question_id, selected_answer, is_correct, answer_time, created_at
`

type UpdateUserAnswerParams struct {
	UserAnswerID   int32  `json:"user_answer_id"`
	SelectedAnswer string `json:"selected_answer"`
	IsCorrect      bool   `json:"is_correct"`
}

func (q *Queries) UpdateUserAnswer(ctx context.Context, arg UpdateUserAnswerParams) (UserAnswer, error) {
	row := q.db.QueryRowContext(ctx, updateUserAnswer, arg.UserAnswerID, arg.SelectedAnswer, arg.IsCorrect)
	var i UserAnswer
	err := row.Scan(
		&i.UserAnswerID,
		&i.AttemptID,
		&i.QuestionID,
		&i.SelectedAnswer,
		&i.IsCorrect,
		&i.AnswerTime,
		&i.CreatedAt,
	)
	return i, err
}

const updateUserAnswerByAttemptAndQuestion = `-- name: UpdateUserAnswerByAttemptAndQuestion :one
UPDATE user_answers
SET 
    selected_answer = $3,
    is_correct = $4,
    answer_time = NOW()
WHERE attempt_id = $1 AND question_id = $2
RETURNING user_answer_id, attempt_id, question_id, selected_answer, is_correct, answer_time, created_at
`

type UpdateUserAnswerByAttemptAndQuestionParams struct {
	AttemptID      int32  `json:"attempt_id"`
	QuestionID     int32  `json:"question_id"`
	SelectedAnswer string `json:"selected_answer"`
	IsCorrect      bool   `json:"is_correct"`
}

func (q *Queries) UpdateUserAnswerByAttemptAndQuestion(ctx context.Context, arg UpdateUserAnswerByAttemptAndQuestionParams) (UserAnswer, error) {
	row := q.db.QueryRowContext(ctx, updateUserAnswerByAttemptAndQuestion,
		arg.AttemptID,
		arg.QuestionID,
		arg.SelectedAnswer,
		arg.IsCorrect,
	)
	var i UserAnswer
	err := row.Scan(
		&i.UserAnswerID,
		&i.AttemptID,
		&i.QuestionID,
		&i.SelectedAnswer,
		&i.IsCorrect,
		&i.AnswerTime,
		&i.CreatedAt,
	)
	return i, err
}
