// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: speakings.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const createSpeakingSession = `-- name: CreateSpeakingSession :one
INSERT INTO speaking_sessions (
    user_id,
    session_topic,
    start_time,
    end_time
) VALUES (
    $1, $2, $3, $4
) RETURNING id, user_id, session_topic, start_time, end_time, updated_at
`

type CreateSpeakingSessionParams struct {
	UserID       int32          `json:"user_id"`
	SessionTopic sql.NullString `json:"session_topic"`
	StartTime    time.Time      `json:"start_time"`
	EndTime      sql.NullTime   `json:"end_time"`
}

func (q *Queries) CreateSpeakingSession(ctx context.Context, arg CreateSpeakingSessionParams) (SpeakingSession, error) {
	row := q.db.QueryRowContext(ctx, createSpeakingSession,
		arg.UserID,
		arg.SessionTopic,
		arg.StartTime,
		arg.EndTime,
	)
	var i SpeakingSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionTopic,
		&i.StartTime,
		&i.EndTime,
		&i.UpdatedAt,
	)
	return i, err
}

const createSpeakingTurn = `-- name: CreateSpeakingTurn :one
INSERT INTO speaking_turns (
    session_id,
    speaker_type,
    text_spoken,
    audio_recording_path,
    "timestamp",
    ai_evaluation,
    ai_score
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
) RETURNING id, session_id, speaker_type, text_spoken, audio_recording_path, timestamp, ai_evaluation, ai_score
`

type CreateSpeakingTurnParams struct {
	SessionID          int32                 `json:"session_id"`
	SpeakerType        string                `json:"speaker_type"`
	TextSpoken         sql.NullString        `json:"text_spoken"`
	AudioRecordingPath sql.NullString        `json:"audio_recording_path"`
	Timestamp          time.Time             `json:"timestamp"`
	AiEvaluation       pqtype.NullRawMessage `json:"ai_evaluation"`
	AiScore            sql.NullString        `json:"ai_score"`
}

func (q *Queries) CreateSpeakingTurn(ctx context.Context, arg CreateSpeakingTurnParams) (SpeakingTurn, error) {
	row := q.db.QueryRowContext(ctx, createSpeakingTurn,
		arg.SessionID,
		arg.SpeakerType,
		arg.TextSpoken,
		arg.AudioRecordingPath,
		arg.Timestamp,
		arg.AiEvaluation,
		arg.AiScore,
	)
	var i SpeakingTurn
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.SpeakerType,
		&i.TextSpoken,
		&i.AudioRecordingPath,
		&i.Timestamp,
		&i.AiEvaluation,
		&i.AiScore,
	)
	return i, err
}

const deleteSpeakingSession = `-- name: DeleteSpeakingSession :exec
DELETE FROM speaking_sessions WHERE id = $1
`

func (q *Queries) DeleteSpeakingSession(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteSpeakingSession, id)
	return err
}

const deleteSpeakingTurn = `-- name: DeleteSpeakingTurn :exec
DELETE FROM speaking_turns WHERE id = $1
`

func (q *Queries) DeleteSpeakingTurn(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteSpeakingTurn, id)
	return err
}

const getSpeakingSession = `-- name: GetSpeakingSession :one
SELECT id, user_id, session_topic, start_time, end_time, updated_at FROM speaking_sessions WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSpeakingSession(ctx context.Context, id int32) (SpeakingSession, error) {
	row := q.db.QueryRowContext(ctx, getSpeakingSession, id)
	var i SpeakingSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionTopic,
		&i.StartTime,
		&i.EndTime,
		&i.UpdatedAt,
	)
	return i, err
}

const getSpeakingTurn = `-- name: GetSpeakingTurn :one
SELECT id, session_id, speaker_type, text_spoken, audio_recording_path, timestamp, ai_evaluation, ai_score FROM speaking_turns WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSpeakingTurn(ctx context.Context, id int32) (SpeakingTurn, error) {
	row := q.db.QueryRowContext(ctx, getSpeakingTurn, id)
	var i SpeakingTurn
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.SpeakerType,
		&i.TextSpoken,
		&i.AudioRecordingPath,
		&i.Timestamp,
		&i.AiEvaluation,
		&i.AiScore,
	)
	return i, err
}

const listSpeakingSessionsByUserID = `-- name: ListSpeakingSessionsByUserID :many
SELECT id, user_id, session_topic, start_time, end_time, updated_at FROM speaking_sessions WHERE user_id = $1 ORDER BY start_time DESC
`

func (q *Queries) ListSpeakingSessionsByUserID(ctx context.Context, userID int32) ([]SpeakingSession, error) {
	rows, err := q.db.QueryContext(ctx, listSpeakingSessionsByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SpeakingSession
	for rows.Next() {
		var i SpeakingSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SessionTopic,
			&i.StartTime,
			&i.EndTime,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSpeakingTurnsBySessionID = `-- name: ListSpeakingTurnsBySessionID :many
SELECT id, session_id, speaker_type, text_spoken, audio_recording_path, timestamp, ai_evaluation, ai_score FROM speaking_turns WHERE session_id = $1 ORDER BY "timestamp" ASC
`

func (q *Queries) ListSpeakingTurnsBySessionID(ctx context.Context, sessionID int32) ([]SpeakingTurn, error) {
	rows, err := q.db.QueryContext(ctx, listSpeakingTurnsBySessionID, sessionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SpeakingTurn
	for rows.Next() {
		var i SpeakingTurn
		if err := rows.Scan(
			&i.ID,
			&i.SessionID,
			&i.SpeakerType,
			&i.TextSpoken,
			&i.AudioRecordingPath,
			&i.Timestamp,
			&i.AiEvaluation,
			&i.AiScore,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSpeakingSession = `-- name: UpdateSpeakingSession :one
UPDATE speaking_sessions
SET session_topic = $2,
    start_time = $3,
    end_time = $4,
    updated_at = NOW()
WHERE id = $1
RETURNING id, user_id, session_topic, start_time, end_time, updated_at
`

type UpdateSpeakingSessionParams struct {
	ID           int32          `json:"id"`
	SessionTopic sql.NullString `json:"session_topic"`
	StartTime    time.Time      `json:"start_time"`
	EndTime      sql.NullTime   `json:"end_time"`
}

func (q *Queries) UpdateSpeakingSession(ctx context.Context, arg UpdateSpeakingSessionParams) (SpeakingSession, error) {
	row := q.db.QueryRowContext(ctx, updateSpeakingSession,
		arg.ID,
		arg.SessionTopic,
		arg.StartTime,
		arg.EndTime,
	)
	var i SpeakingSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SessionTopic,
		&i.StartTime,
		&i.EndTime,
		&i.UpdatedAt,
	)
	return i, err
}

const updateSpeakingTurn = `-- name: UpdateSpeakingTurn :one
UPDATE speaking_turns
SET text_spoken = $2,
    audio_recording_path = $3,
    ai_evaluation = $4,
    ai_score = $5,
    "timestamp" = $6
WHERE id = $1
RETURNING id, session_id, speaker_type, text_spoken, audio_recording_path, timestamp, ai_evaluation, ai_score
`

type UpdateSpeakingTurnParams struct {
	ID                 int32                 `json:"id"`
	TextSpoken         sql.NullString        `json:"text_spoken"`
	AudioRecordingPath sql.NullString        `json:"audio_recording_path"`
	AiEvaluation       pqtype.NullRawMessage `json:"ai_evaluation"`
	AiScore            sql.NullString        `json:"ai_score"`
	Timestamp          time.Time             `json:"timestamp"`
}

func (q *Queries) UpdateSpeakingTurn(ctx context.Context, arg UpdateSpeakingTurnParams) (SpeakingTurn, error) {
	row := q.db.QueryRowContext(ctx, updateSpeakingTurn,
		arg.ID,
		arg.TextSpoken,
		arg.AudioRecordingPath,
		arg.AiEvaluation,
		arg.AiScore,
		arg.Timestamp,
	)
	var i SpeakingTurn
	err := row.Scan(
		&i.ID,
		&i.SessionID,
		&i.SpeakerType,
		&i.TextSpoken,
		&i.AudioRecordingPath,
		&i.Timestamp,
		&i.AiEvaluation,
		&i.AiScore,
	)
	return i, err
}
