// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: vocabulary_stats.sql

package db

import (
	"context"
	"database/sql"
)

const createOrUpdateVocabularyStats = `-- name: CreateOrUpdateVocabularyStats :one

INSERT INTO vocabulary_stats (
  user_id,
  word_id,
  total_attempts,
  correct_attempts,
  total_response_time_ms,
  mastery_level,
  last_attempt_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
ON CONFLICT (user_id, word_id)
DO UPDATE SET
  total_attempts = vocabulary_stats.total_attempts + EXCLUDED.total_attempts,
  correct_attempts = vocabulary_stats.correct_attempts + EXCLUDED.correct_attempts,
  total_response_time_ms = vocabulary_stats.total_response_time_ms + EXCLUDED.total_response_time_ms,
  mastery_level = EXCLUDED.mastery_level,
  last_attempt_at = EXCLUDED.last_attempt_at,
  updated_at = NOW()
RETURNING id, user_id, word_id, total_attempts, correct_attempts, total_response_time_ms, mastery_level, last_attempt_at, created_at, updated_at
`

type CreateOrUpdateVocabularyStatsParams struct {
	UserID              int32         `json:"user_id"`
	WordID              int32         `json:"word_id"`
	TotalAttempts       sql.NullInt32 `json:"total_attempts"`
	CorrectAttempts     sql.NullInt32 `json:"correct_attempts"`
	TotalResponseTimeMs sql.NullInt64 `json:"total_response_time_ms"`
	MasteryLevel        sql.NullInt32 `json:"mastery_level"`
	LastAttemptAt       sql.NullTime  `json:"last_attempt_at"`
}

// Vocabulary Statistics Queries
func (q *Queries) CreateOrUpdateVocabularyStats(ctx context.Context, arg CreateOrUpdateVocabularyStatsParams) (VocabularyStat, error) {
	row := q.db.QueryRowContext(ctx, createOrUpdateVocabularyStats,
		arg.UserID,
		arg.WordID,
		arg.TotalAttempts,
		arg.CorrectAttempts,
		arg.TotalResponseTimeMs,
		arg.MasteryLevel,
		arg.LastAttemptAt,
	)
	var i VocabularyStat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WordID,
		&i.TotalAttempts,
		&i.CorrectAttempts,
		&i.TotalResponseTimeMs,
		&i.MasteryLevel,
		&i.LastAttemptAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteVocabularyStats = `-- name: DeleteVocabularyStats :exec
DELETE FROM vocabulary_stats
WHERE user_id = $1 AND word_id = $2
`

type DeleteVocabularyStatsParams struct {
	UserID int32 `json:"user_id"`
	WordID int32 `json:"word_id"`
}

func (q *Queries) DeleteVocabularyStats(ctx context.Context, arg DeleteVocabularyStatsParams) error {
	_, err := q.db.ExecContext(ctx, deleteVocabularyStats, arg.UserID, arg.WordID)
	return err
}

const getUserLearningProgress = `-- name: GetUserLearningProgress :one
SELECT 
  COUNT(*) as total_words_studied,
  SUM(CASE WHEN mastery_level >= 8 THEN 1 ELSE 0 END) as mastered_words,
  AVG(mastery_level) as average_mastery,
  SUM(total_attempts) as total_attempts,
  SUM(correct_attempts) as total_correct,
  SUM(total_response_time_ms) as total_study_time_ms
FROM vocabulary_stats
WHERE user_id = $1
`

type GetUserLearningProgressRow struct {
	TotalWordsStudied int64   `json:"total_words_studied"`
	MasteredWords     int64   `json:"mastered_words"`
	AverageMastery    float64 `json:"average_mastery"`
	TotalAttempts     int64   `json:"total_attempts"`
	TotalCorrect      int64   `json:"total_correct"`
	TotalStudyTimeMs  int64   `json:"total_study_time_ms"`
}

func (q *Queries) GetUserLearningProgress(ctx context.Context, userID int32) (GetUserLearningProgressRow, error) {
	row := q.db.QueryRowContext(ctx, getUserLearningProgress, userID)
	var i GetUserLearningProgressRow
	err := row.Scan(
		&i.TotalWordsStudied,
		&i.MasteredWords,
		&i.AverageMastery,
		&i.TotalAttempts,
		&i.TotalCorrect,
		&i.TotalStudyTimeMs,
	)
	return i, err
}

const getUserMasteryDistribution = `-- name: GetUserMasteryDistribution :many
SELECT 
  mastery_level,
  COUNT(*) as word_count
FROM vocabulary_stats
WHERE user_id = $1
GROUP BY mastery_level
ORDER BY mastery_level
`

type GetUserMasteryDistributionRow struct {
	MasteryLevel sql.NullInt32 `json:"mastery_level"`
	WordCount    int64         `json:"word_count"`
}

func (q *Queries) GetUserMasteryDistribution(ctx context.Context, userID int32) ([]GetUserMasteryDistributionRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserMasteryDistribution, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserMasteryDistributionRow
	for rows.Next() {
		var i GetUserMasteryDistributionRow
		if err := rows.Scan(&i.MasteryLevel, &i.WordCount); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getVocabularyStats = `-- name: GetVocabularyStats :one
SELECT id, user_id, word_id, total_attempts, correct_attempts, total_response_time_ms, mastery_level, last_attempt_at, created_at, updated_at FROM vocabulary_stats
WHERE user_id = $1 AND word_id = $2
`

type GetVocabularyStatsParams struct {
	UserID int32 `json:"user_id"`
	WordID int32 `json:"word_id"`
}

func (q *Queries) GetVocabularyStats(ctx context.Context, arg GetVocabularyStatsParams) (VocabularyStat, error) {
	row := q.db.QueryRowContext(ctx, getVocabularyStats, arg.UserID, arg.WordID)
	var i VocabularyStat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WordID,
		&i.TotalAttempts,
		&i.CorrectAttempts,
		&i.TotalResponseTimeMs,
		&i.MasteryLevel,
		&i.LastAttemptAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWordsNeedingReview = `-- name: GetWordsNeedingReview :many
SELECT words.id, words.word, words.pronounce, words.level, words.descript_level, words.short_mean, words.means, words.snym, words.freq, words.conjugation, vocabulary_stats.id, vocabulary_stats.user_id, vocabulary_stats.word_id, vocabulary_stats.total_attempts, vocabulary_stats.correct_attempts, vocabulary_stats.total_response_time_ms, vocabulary_stats.mastery_level, vocabulary_stats.last_attempt_at, vocabulary_stats.created_at, vocabulary_stats.updated_at
FROM words
LEFT JOIN vocabulary_stats ON words.id = vocabulary_stats.word_id AND vocabulary_stats.user_id = $1
WHERE vocabulary_stats.mastery_level < $2 OR vocabulary_stats.mastery_level IS NULL
ORDER BY vocabulary_stats.last_attempt_at ASC NULLS FIRST
LIMIT $3
`

type GetWordsNeedingReviewParams struct {
	UserID       int32         `json:"user_id"`
	MasteryLevel sql.NullInt32 `json:"mastery_level"`
	Limit        int32         `json:"limit"`
}

type GetWordsNeedingReviewRow struct {
	Word           Word           `json:"word"`
	VocabularyStat VocabularyStat `json:"vocabulary_stat"`
}

func (q *Queries) GetWordsNeedingReview(ctx context.Context, arg GetWordsNeedingReviewParams) ([]GetWordsNeedingReviewRow, error) {
	rows, err := q.db.QueryContext(ctx, getWordsNeedingReview, arg.UserID, arg.MasteryLevel, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWordsNeedingReviewRow
	for rows.Next() {
		var i GetWordsNeedingReviewRow
		if err := rows.Scan(
			&i.Word.ID,
			&i.Word.Word,
			&i.Word.Pronounce,
			&i.Word.Level,
			&i.Word.DescriptLevel,
			&i.Word.ShortMean,
			&i.Word.Means,
			&i.Word.Snym,
			&i.Word.Freq,
			&i.Word.Conjugation,
			&i.VocabularyStat.ID,
			&i.VocabularyStat.UserID,
			&i.VocabularyStat.WordID,
			&i.VocabularyStat.TotalAttempts,
			&i.VocabularyStat.CorrectAttempts,
			&i.VocabularyStat.TotalResponseTimeMs,
			&i.VocabularyStat.MasteryLevel,
			&i.VocabularyStat.LastAttemptAt,
			&i.VocabularyStat.CreatedAt,
			&i.VocabularyStat.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserVocabularyStats = `-- name: ListUserVocabularyStats :many
SELECT vocabulary_stats.id, vocabulary_stats.user_id, vocabulary_stats.word_id, vocabulary_stats.total_attempts, vocabulary_stats.correct_attempts, vocabulary_stats.total_response_time_ms, vocabulary_stats.mastery_level, vocabulary_stats.last_attempt_at, vocabulary_stats.created_at, vocabulary_stats.updated_at, words.id, words.word, words.pronounce, words.level, words.descript_level, words.short_mean, words.means, words.snym, words.freq, words.conjugation
FROM vocabulary_stats
JOIN words ON vocabulary_stats.word_id = words.id
WHERE vocabulary_stats.user_id = $1
ORDER BY vocabulary_stats.last_attempt_at DESC
LIMIT $2 OFFSET $3
`

type ListUserVocabularyStatsParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListUserVocabularyStatsRow struct {
	VocabularyStat VocabularyStat `json:"vocabulary_stat"`
	Word           Word           `json:"word"`
}

func (q *Queries) ListUserVocabularyStats(ctx context.Context, arg ListUserVocabularyStatsParams) ([]ListUserVocabularyStatsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserVocabularyStats, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserVocabularyStatsRow
	for rows.Next() {
		var i ListUserVocabularyStatsRow
		if err := rows.Scan(
			&i.VocabularyStat.ID,
			&i.VocabularyStat.UserID,
			&i.VocabularyStat.WordID,
			&i.VocabularyStat.TotalAttempts,
			&i.VocabularyStat.CorrectAttempts,
			&i.VocabularyStat.TotalResponseTimeMs,
			&i.VocabularyStat.MasteryLevel,
			&i.VocabularyStat.LastAttemptAt,
			&i.VocabularyStat.CreatedAt,
			&i.VocabularyStat.UpdatedAt,
			&i.Word.ID,
			&i.Word.Word,
			&i.Word.Pronounce,
			&i.Word.Level,
			&i.Word.DescriptLevel,
			&i.Word.ShortMean,
			&i.Word.Means,
			&i.Word.Snym,
			&i.Word.Freq,
			&i.Word.Conjugation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWordMastery = `-- name: UpdateWordMastery :one
UPDATE vocabulary_stats
SET
  mastery_level = $3,
  updated_at = NOW()
WHERE user_id = $1 AND word_id = $2
RETURNING id, user_id, word_id, total_attempts, correct_attempts, total_response_time_ms, mastery_level, last_attempt_at, created_at, updated_at
`

type UpdateWordMasteryParams struct {
	UserID       int32         `json:"user_id"`
	WordID       int32         `json:"word_id"`
	MasteryLevel sql.NullInt32 `json:"mastery_level"`
}

func (q *Queries) UpdateWordMastery(ctx context.Context, arg UpdateWordMasteryParams) (VocabularyStat, error) {
	row := q.db.QueryRowContext(ctx, updateWordMastery, arg.UserID, arg.WordID, arg.MasteryLevel)
	var i VocabularyStat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.WordID,
		&i.TotalAttempts,
		&i.CorrectAttempts,
		&i.TotalResponseTimeMs,
		&i.MasteryLevel,
		&i.LastAttemptAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
