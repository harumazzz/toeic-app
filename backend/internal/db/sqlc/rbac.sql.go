// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: rbac.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const assignPermissionToRole = `-- name: AssignPermissionToRole :exec
INSERT INTO role_permissions (role_id, permission_id)
VALUES ($1, $2)
ON CONFLICT (role_id, permission_id) DO NOTHING
`

type AssignPermissionToRoleParams struct {
	RoleID       int32 `json:"role_id"`
	PermissionID int32 `json:"permission_id"`
}

func (q *Queries) AssignPermissionToRole(ctx context.Context, arg AssignPermissionToRoleParams) error {
	_, err := q.db.ExecContext(ctx, assignPermissionToRole, arg.RoleID, arg.PermissionID)
	return err
}

const assignRoleToUser = `-- name: AssignRoleToUser :exec
INSERT INTO user_roles (user_id, role_id, assigned_by, expires_at)
VALUES ($1, $2, $3, $4)
ON CONFLICT (user_id, role_id) DO UPDATE SET
    assigned_at = NOW(),
    assigned_by = $3,
    expires_at = $4
`

type AssignRoleToUserParams struct {
	UserID     int32         `json:"user_id"`
	RoleID     int32         `json:"role_id"`
	AssignedBy sql.NullInt32 `json:"assigned_by"`
	ExpiresAt  sql.NullTime  `json:"expires_at"`
}

func (q *Queries) AssignRoleToUser(ctx context.Context, arg AssignRoleToUserParams) error {
	_, err := q.db.ExecContext(ctx, assignRoleToUser,
		arg.UserID,
		arg.RoleID,
		arg.AssignedBy,
		arg.ExpiresAt,
	)
	return err
}

const checkUserPermission = `-- name: CheckUserPermission :one
SELECT COUNT(*) > 0 as has_permission FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
JOIN user_roles ur ON rp.role_id = ur.role_id
WHERE ur.user_id = $1 
AND p.name = $2
AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
`

type CheckUserPermissionParams struct {
	UserID int32  `json:"user_id"`
	Name   string `json:"name"`
}

func (q *Queries) CheckUserPermission(ctx context.Context, arg CheckUserPermissionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserPermission, arg.UserID, arg.Name)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}

const checkUserPermissionByResourceAction = `-- name: CheckUserPermissionByResourceAction :one
SELECT COUNT(*) > 0 as has_permission FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
JOIN user_roles ur ON rp.role_id = ur.role_id
WHERE ur.user_id = $1 
AND p.resource = $2 
AND p.action = $3
AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
`

type CheckUserPermissionByResourceActionParams struct {
	UserID   int32  `json:"user_id"`
	Resource string `json:"resource"`
	Action   string `json:"action"`
}

func (q *Queries) CheckUserPermissionByResourceAction(ctx context.Context, arg CheckUserPermissionByResourceActionParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkUserPermissionByResourceAction, arg.UserID, arg.Resource, arg.Action)
	var has_permission bool
	err := row.Scan(&has_permission)
	return has_permission, err
}

const cleanupExpiredRoles = `-- name: CleanupExpiredRoles :exec
DELETE FROM user_roles 
WHERE expires_at IS NOT NULL AND expires_at <= NOW()
`

func (q *Queries) CleanupExpiredRoles(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, cleanupExpiredRoles)
	return err
}

const createPermission = `-- name: CreatePermission :one
INSERT INTO permissions (name, resource, action, description)
VALUES ($1, $2, $3, $4)
RETURNING id, name, resource, action, description, created_at
`

type CreatePermissionParams struct {
	Name        string         `json:"name"`
	Resource    string         `json:"resource"`
	Action      string         `json:"action"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (Permission, error) {
	row := q.db.QueryRowContext(ctx, createPermission,
		arg.Name,
		arg.Resource,
		arg.Action,
		arg.Description,
	)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Resource,
		&i.Action,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (name, description)
VALUES ($1, $2)
RETURNING id, name, description, created_at, updated_at
`

type CreateRoleParams struct {
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRowContext(ctx, createRole, arg.Name, arg.Description)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions WHERE id = $1
`

func (q *Queries) DeletePermission(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deletePermission, id)
	return err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles WHERE id = $1
`

func (q *Queries) DeleteRole(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, deleteRole, id)
	return err
}

const getPermission = `-- name: GetPermission :one
SELECT id, name, resource, action, description, created_at FROM permissions WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPermission(ctx context.Context, id int32) (Permission, error) {
	row := q.db.QueryRowContext(ctx, getPermission, id)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Resource,
		&i.Action,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getPermissionByName = `-- name: GetPermissionByName :one
SELECT id, name, resource, action, description, created_at FROM permissions WHERE name = $1 LIMIT 1
`

func (q *Queries) GetPermissionByName(ctx context.Context, name string) (Permission, error) {
	row := q.db.QueryRowContext(ctx, getPermissionByName, name)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Resource,
		&i.Action,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getRole = `-- name: GetRole :one
SELECT id, name, description, created_at, updated_at FROM roles WHERE id = $1 LIMIT 1
`

func (q *Queries) GetRole(ctx context.Context, id int32) (Role, error) {
	row := q.db.QueryRowContext(ctx, getRole, id)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT id, name, description, created_at, updated_at FROM roles WHERE name = $1 LIMIT 1
`

func (q *Queries) GetRoleByName(ctx context.Context, name string) (Role, error) {
	row := q.db.QueryRowContext(ctx, getRoleByName, name)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRolePermissions = `-- name: GetRolePermissions :many
SELECT p.id, p.name, p.resource, p.action, p.description, p.created_at FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
WHERE rp.role_id = $1
ORDER BY p.resource, p.action
`

func (q *Queries) GetRolePermissions(ctx context.Context, roleID int32) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, getRolePermissions, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Resource,
			&i.Action,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserPermissions = `-- name: GetUserPermissions :many
SELECT DISTINCT p.id, p.name, p.resource, p.action, p.description, p.created_at FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
JOIN user_roles ur ON rp.role_id = ur.role_id
WHERE ur.user_id = $1 
AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
ORDER BY p.resource, p.action
`

func (q *Queries) GetUserPermissions(ctx context.Context, userID int32) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, getUserPermissions, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Resource,
			&i.Action,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRoleAssignments = `-- name: GetUserRoleAssignments :many
SELECT ur.user_id, ur.role_id, ur.assigned_at, ur.assigned_by, ur.expires_at, r.name as role_name, r.description as role_description
FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
WHERE ur.user_id = $1
ORDER BY ur.assigned_at DESC
`

type GetUserRoleAssignmentsRow struct {
	UserID          int32          `json:"user_id"`
	RoleID          int32          `json:"role_id"`
	AssignedAt      time.Time      `json:"assigned_at"`
	AssignedBy      sql.NullInt32  `json:"assigned_by"`
	ExpiresAt       sql.NullTime   `json:"expires_at"`
	RoleName        string         `json:"role_name"`
	RoleDescription sql.NullString `json:"role_description"`
}

func (q *Queries) GetUserRoleAssignments(ctx context.Context, userID int32) ([]GetUserRoleAssignmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserRoleAssignments, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserRoleAssignmentsRow
	for rows.Next() {
		var i GetUserRoleAssignmentsRow
		if err := rows.Scan(
			&i.UserID,
			&i.RoleID,
			&i.AssignedAt,
			&i.AssignedBy,
			&i.ExpiresAt,
			&i.RoleName,
			&i.RoleDescription,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.id, r.name, r.description, r.created_at, r.updated_at FROM roles r
JOIN user_roles ur ON r.id = ur.role_id
WHERE ur.user_id = $1 
AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
ORDER BY r.name
`

func (q *Queries) GetUserRoles(ctx context.Context, userID int32) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByRole = `-- name: GetUsersByRole :many
SELECT ur.user_id FROM user_roles ur
JOIN roles r ON ur.role_id = r.id
WHERE r.name = $1
AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
ORDER BY ur.user_id
`

func (q *Queries) GetUsersByRole(ctx context.Context, name string) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getUsersByRole, name)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var user_id int32
		if err := rows.Scan(&user_id); err != nil {
			return nil, err
		}
		items = append(items, user_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPermissions = `-- name: ListPermissions :many
SELECT id, name, resource, action, description, created_at FROM permissions ORDER BY resource, action
`

func (q *Queries) ListPermissions(ctx context.Context) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, listPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Resource,
			&i.Action,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPermissionsByResource = `-- name: ListPermissionsByResource :many
SELECT id, name, resource, action, description, created_at FROM permissions WHERE resource = $1 ORDER BY action
`

func (q *Queries) ListPermissionsByResource(ctx context.Context, resource string) ([]Permission, error) {
	rows, err := q.db.QueryContext(ctx, listPermissionsByResource, resource)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Permission
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Resource,
			&i.Action,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoles = `-- name: ListRoles :many
SELECT id, name, description, created_at, updated_at FROM roles ORDER BY name
`

func (q *Queries) ListRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.QueryContext(ctx, listRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Role
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersWithRole = `-- name: ListUsersWithRole :many
SELECT u.id, u.username, u.email, u.password_hash, u.created_at, u.updated_at FROM users u
JOIN user_roles ur ON u.id = ur.user_id
WHERE ur.role_id = $1
AND (ur.expires_at IS NULL OR ur.expires_at > NOW())
ORDER BY u.username
`

func (q *Queries) ListUsersWithRole(ctx context.Context, roleID int32) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsersWithRole, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.PasswordHash,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePermissionFromRole = `-- name: RemovePermissionFromRole :exec
DELETE FROM role_permissions 
WHERE role_id = $1 AND permission_id = $2
`

type RemovePermissionFromRoleParams struct {
	RoleID       int32 `json:"role_id"`
	PermissionID int32 `json:"permission_id"`
}

func (q *Queries) RemovePermissionFromRole(ctx context.Context, arg RemovePermissionFromRoleParams) error {
	_, err := q.db.ExecContext(ctx, removePermissionFromRole, arg.RoleID, arg.PermissionID)
	return err
}

const removeRoleFromUser = `-- name: RemoveRoleFromUser :exec
DELETE FROM user_roles 
WHERE user_id = $1 AND role_id = $2
`

type RemoveRoleFromUserParams struct {
	UserID int32 `json:"user_id"`
	RoleID int32 `json:"role_id"`
}

func (q *Queries) RemoveRoleFromUser(ctx context.Context, arg RemoveRoleFromUserParams) error {
	_, err := q.db.ExecContext(ctx, removeRoleFromUser, arg.UserID, arg.RoleID)
	return err
}

const updatePermission = `-- name: UpdatePermission :one
UPDATE permissions
SET name = $2, resource = $3, action = $4, description = $5
WHERE id = $1
RETURNING id, name, resource, action, description, created_at
`

type UpdatePermissionParams struct {
	ID          int32          `json:"id"`
	Name        string         `json:"name"`
	Resource    string         `json:"resource"`
	Action      string         `json:"action"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) UpdatePermission(ctx context.Context, arg UpdatePermissionParams) (Permission, error) {
	row := q.db.QueryRowContext(ctx, updatePermission,
		arg.ID,
		arg.Name,
		arg.Resource,
		arg.Action,
		arg.Description,
	)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Resource,
		&i.Action,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles
SET name = $2, description = $3, updated_at = NOW()
WHERE id = $1
RETURNING id, name, description, created_at, updated_at
`

type UpdateRoleParams struct {
	ID          int32          `json:"id"`
	Name        string         `json:"name"`
	Description sql.NullString `json:"description"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (Role, error) {
	row := q.db.QueryRowContext(ctx, updateRole, arg.ID, arg.Name, arg.Description)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
