// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: user_word_progress.sql

package db

import (
	"context"
	"database/sql"
)

const createUserWordProgress = `-- name: CreateUserWordProgress :one
INSERT INTO user_word_progress (
  user_id,
  word_id,
  last_reviewed_at,
  next_review_at,
  interval_days,
  ease_factor,
  repetitions
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING user_id, word_id, last_reviewed_at, next_review_at, interval_days, ease_factor, repetitions, created_at, updated_at
`

type CreateUserWordProgressParams struct {
	UserID         int32        `json:"user_id"`
	WordID         int32        `json:"word_id"`
	LastReviewedAt sql.NullTime `json:"last_reviewed_at"`
	NextReviewAt   sql.NullTime `json:"next_review_at"`
	IntervalDays   int32        `json:"interval_days"`
	EaseFactor     float32      `json:"ease_factor"`
	Repetitions    int32        `json:"repetitions"`
}

func (q *Queries) CreateUserWordProgress(ctx context.Context, arg CreateUserWordProgressParams) (UserWordProgress, error) {
	row := q.db.QueryRowContext(ctx, createUserWordProgress,
		arg.UserID,
		arg.WordID,
		arg.LastReviewedAt,
		arg.NextReviewAt,
		arg.IntervalDays,
		arg.EaseFactor,
		arg.Repetitions,
	)
	var i UserWordProgress
	err := row.Scan(
		&i.UserID,
		&i.WordID,
		&i.LastReviewedAt,
		&i.NextReviewAt,
		&i.IntervalDays,
		&i.EaseFactor,
		&i.Repetitions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteUserWordProgress = `-- name: DeleteUserWordProgress :exec
DELETE FROM user_word_progress
WHERE user_id = $1 AND word_id = $2
`

type DeleteUserWordProgressParams struct {
	UserID int32 `json:"user_id"`
	WordID int32 `json:"word_id"`
}

func (q *Queries) DeleteUserWordProgress(ctx context.Context, arg DeleteUserWordProgressParams) error {
	_, err := q.db.ExecContext(ctx, deleteUserWordProgress, arg.UserID, arg.WordID)
	return err
}

const getAllUserSavedWords = `-- name: GetAllUserSavedWords :many
SELECT words.id, words.word, words.pronounce, words.level, words.descript_level, words.short_mean, words.means, words.snym, words.freq, words.conjugation, user_word_progress.user_id, user_word_progress.word_id, user_word_progress.last_reviewed_at, user_word_progress.next_review_at, user_word_progress.interval_days, user_word_progress.ease_factor, user_word_progress.repetitions, user_word_progress.created_at, user_word_progress.updated_at
FROM words
JOIN user_word_progress ON words.id = user_word_progress.word_id
WHERE user_word_progress.user_id = $1
ORDER BY user_word_progress.created_at DESC
LIMIT $2 OFFSET $3
`

type GetAllUserSavedWordsParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetAllUserSavedWordsRow struct {
	Word             Word             `json:"word"`
	UserWordProgress UserWordProgress `json:"user_word_progress"`
}

func (q *Queries) GetAllUserSavedWords(ctx context.Context, arg GetAllUserSavedWordsParams) ([]GetAllUserSavedWordsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllUserSavedWords, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllUserSavedWordsRow
	for rows.Next() {
		var i GetAllUserSavedWordsRow
		if err := rows.Scan(
			&i.Word.ID,
			&i.Word.Word,
			&i.Word.Pronounce,
			&i.Word.Level,
			&i.Word.DescriptLevel,
			&i.Word.ShortMean,
			&i.Word.Means,
			&i.Word.Snym,
			&i.Word.Freq,
			&i.Word.Conjugation,
			&i.UserWordProgress.UserID,
			&i.UserWordProgress.WordID,
			&i.UserWordProgress.LastReviewedAt,
			&i.UserWordProgress.NextReviewAt,
			&i.UserWordProgress.IntervalDays,
			&i.UserWordProgress.EaseFactor,
			&i.UserWordProgress.Repetitions,
			&i.UserWordProgress.CreatedAt,
			&i.UserWordProgress.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserWordProgress = `-- name: GetUserWordProgress :one
SELECT user_id, word_id, last_reviewed_at, next_review_at, interval_days, ease_factor, repetitions, created_at, updated_at FROM user_word_progress
WHERE user_id = $1 AND word_id = $2
`

type GetUserWordProgressParams struct {
	UserID int32 `json:"user_id"`
	WordID int32 `json:"word_id"`
}

func (q *Queries) GetUserWordProgress(ctx context.Context, arg GetUserWordProgressParams) (UserWordProgress, error) {
	row := q.db.QueryRowContext(ctx, getUserWordProgress, arg.UserID, arg.WordID)
	var i UserWordProgress
	err := row.Scan(
		&i.UserID,
		&i.WordID,
		&i.LastReviewedAt,
		&i.NextReviewAt,
		&i.IntervalDays,
		&i.EaseFactor,
		&i.Repetitions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWordWithProgress = `-- name: GetWordWithProgress :one
SELECT words.id, words.word, words.pronounce, words.level, words.descript_level, words.short_mean, words.means, words.snym, words.freq, words.conjugation, user_word_progress.user_id, user_word_progress.word_id, user_word_progress.last_reviewed_at, user_word_progress.next_review_at, user_word_progress.interval_days, user_word_progress.ease_factor, user_word_progress.repetitions, user_word_progress.created_at, user_word_progress.updated_at
FROM words
LEFT JOIN user_word_progress ON words.id = user_word_progress.word_id AND user_word_progress.user_id = $2
WHERE words.id = $1
`

type GetWordWithProgressParams struct {
	ID     int32 `json:"id"`
	UserID int32 `json:"user_id"`
}

type GetWordWithProgressRow struct {
	Word             Word             `json:"word"`
	UserWordProgress UserWordProgress `json:"user_word_progress"`
}

func (q *Queries) GetWordWithProgress(ctx context.Context, arg GetWordWithProgressParams) (GetWordWithProgressRow, error) {
	row := q.db.QueryRowContext(ctx, getWordWithProgress, arg.ID, arg.UserID)
	var i GetWordWithProgressRow
	err := row.Scan(
		&i.Word.ID,
		&i.Word.Word,
		&i.Word.Pronounce,
		&i.Word.Level,
		&i.Word.DescriptLevel,
		&i.Word.ShortMean,
		&i.Word.Means,
		&i.Word.Snym,
		&i.Word.Freq,
		&i.Word.Conjugation,
		&i.UserWordProgress.UserID,
		&i.UserWordProgress.WordID,
		&i.UserWordProgress.LastReviewedAt,
		&i.UserWordProgress.NextReviewAt,
		&i.UserWordProgress.IntervalDays,
		&i.UserWordProgress.EaseFactor,
		&i.UserWordProgress.Repetitions,
		&i.UserWordProgress.CreatedAt,
		&i.UserWordProgress.UpdatedAt,
	)
	return i, err
}

const getWordsForReview = `-- name: GetWordsForReview :many
SELECT words.id, words.word, words.pronounce, words.level, words.descript_level, words.short_mean, words.means, words.snym, words.freq, words.conjugation, user_word_progress.user_id, user_word_progress.word_id, user_word_progress.last_reviewed_at, user_word_progress.next_review_at, user_word_progress.interval_days, user_word_progress.ease_factor, user_word_progress.repetitions, user_word_progress.created_at, user_word_progress.updated_at
FROM words
JOIN user_word_progress ON words.id = user_word_progress.word_id
WHERE user_word_progress.user_id = $1
  AND user_word_progress.next_review_at <= NOW()
ORDER BY user_word_progress.next_review_at
`

type GetWordsForReviewRow struct {
	Word             Word             `json:"word"`
	UserWordProgress UserWordProgress `json:"user_word_progress"`
}

func (q *Queries) GetWordsForReview(ctx context.Context, userID int32) ([]GetWordsForReviewRow, error) {
	rows, err := q.db.QueryContext(ctx, getWordsForReview, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetWordsForReviewRow
	for rows.Next() {
		var i GetWordsForReviewRow
		if err := rows.Scan(
			&i.Word.ID,
			&i.Word.Word,
			&i.Word.Pronounce,
			&i.Word.Level,
			&i.Word.DescriptLevel,
			&i.Word.ShortMean,
			&i.Word.Means,
			&i.Word.Snym,
			&i.Word.Freq,
			&i.Word.Conjugation,
			&i.UserWordProgress.UserID,
			&i.UserWordProgress.WordID,
			&i.UserWordProgress.LastReviewedAt,
			&i.UserWordProgress.NextReviewAt,
			&i.UserWordProgress.IntervalDays,
			&i.UserWordProgress.EaseFactor,
			&i.UserWordProgress.Repetitions,
			&i.UserWordProgress.CreatedAt,
			&i.UserWordProgress.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserWordProgressByNextReview = `-- name: ListUserWordProgressByNextReview :many
SELECT user_id, word_id, last_reviewed_at, next_review_at, interval_days, ease_factor, repetitions, created_at, updated_at FROM user_word_progress
WHERE user_id = $1 AND next_review_at <= $2
ORDER BY next_review_at
`

type ListUserWordProgressByNextReviewParams struct {
	UserID       int32        `json:"user_id"`
	NextReviewAt sql.NullTime `json:"next_review_at"`
}

func (q *Queries) ListUserWordProgressByNextReview(ctx context.Context, arg ListUserWordProgressByNextReviewParams) ([]UserWordProgress, error) {
	rows, err := q.db.QueryContext(ctx, listUserWordProgressByNextReview, arg.UserID, arg.NextReviewAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []UserWordProgress
	for rows.Next() {
		var i UserWordProgress
		if err := rows.Scan(
			&i.UserID,
			&i.WordID,
			&i.LastReviewedAt,
			&i.NextReviewAt,
			&i.IntervalDays,
			&i.EaseFactor,
			&i.Repetitions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserWordProgress = `-- name: UpdateUserWordProgress :one
UPDATE user_word_progress
SET
  last_reviewed_at = $3,
  next_review_at = $4,
  interval_days = $5,
  ease_factor = $6,
  repetitions = $7,
  updated_at = NOW()
WHERE user_id = $1 AND word_id = $2
RETURNING user_id, word_id, last_reviewed_at, next_review_at, interval_days, ease_factor, repetitions, created_at, updated_at
`

type UpdateUserWordProgressParams struct {
	UserID         int32        `json:"user_id"`
	WordID         int32        `json:"word_id"`
	LastReviewedAt sql.NullTime `json:"last_reviewed_at"`
	NextReviewAt   sql.NullTime `json:"next_review_at"`
	IntervalDays   int32        `json:"interval_days"`
	EaseFactor     float32      `json:"ease_factor"`
	Repetitions    int32        `json:"repetitions"`
}

func (q *Queries) UpdateUserWordProgress(ctx context.Context, arg UpdateUserWordProgressParams) (UserWordProgress, error) {
	row := q.db.QueryRowContext(ctx, updateUserWordProgress,
		arg.UserID,
		arg.WordID,
		arg.LastReviewedAt,
		arg.NextReviewAt,
		arg.IntervalDays,
		arg.EaseFactor,
		arg.Repetitions,
	)
	var i UserWordProgress
	err := row.Scan(
		&i.UserID,
		&i.WordID,
		&i.LastReviewedAt,
		&i.NextReviewAt,
		&i.IntervalDays,
		&i.EaseFactor,
		&i.Repetitions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
