// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: exam_attempts.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const abandonExamAttempt = `-- name: AbandonExamAttempt :one
UPDATE exam_attempts
SET 
    status = 'abandoned',
    end_time = NOW(),
    updated_at = NOW()
WHERE attempt_id = $1
RETURNING attempt_id, user_id, exam_id, start_time, end_time, score, status, created_at, updated_at
`

func (q *Queries) AbandonExamAttempt(ctx context.Context, attemptID int32) (ExamAttempt, error) {
	row := q.db.QueryRowContext(ctx, abandonExamAttempt, attemptID)
	var i ExamAttempt
	err := row.Scan(
		&i.AttemptID,
		&i.UserID,
		&i.ExamID,
		&i.StartTime,
		&i.EndTime,
		&i.Score,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const completeExamAttempt = `-- name: CompleteExamAttempt :one
UPDATE exam_attempts
SET 
    status = 'completed',
    end_time = NOW(),
    score = $2,
    updated_at = NOW()
WHERE attempt_id = $1
RETURNING attempt_id, user_id, exam_id, start_time, end_time, score, status, created_at, updated_at
`

type CompleteExamAttemptParams struct {
	AttemptID int32          `json:"attempt_id"`
	Score     sql.NullString `json:"score"`
}

func (q *Queries) CompleteExamAttempt(ctx context.Context, arg CompleteExamAttemptParams) (ExamAttempt, error) {
	row := q.db.QueryRowContext(ctx, completeExamAttempt, arg.AttemptID, arg.Score)
	var i ExamAttempt
	err := row.Scan(
		&i.AttemptID,
		&i.UserID,
		&i.ExamID,
		&i.StartTime,
		&i.EndTime,
		&i.Score,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countExamAttemptsByExam = `-- name: CountExamAttemptsByExam :one
SELECT COUNT(*) FROM exam_attempts
WHERE exam_id = $1
`

func (q *Queries) CountExamAttemptsByExam(ctx context.Context, examID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countExamAttemptsByExam, examID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countExamAttemptsByUser = `-- name: CountExamAttemptsByUser :one
SELECT COUNT(*) FROM exam_attempts
WHERE user_id = $1
`

func (q *Queries) CountExamAttemptsByUser(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, countExamAttemptsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createExamAttempt = `-- name: CreateExamAttempt :one
INSERT INTO exam_attempts (
    user_id,
    exam_id,
    start_time,
    status
) VALUES (
    $1, $2, $3, $4
) RETURNING attempt_id, user_id, exam_id, start_time, end_time, score, status, created_at, updated_at
`

type CreateExamAttemptParams struct {
	UserID    int32          `json:"user_id"`
	ExamID    int32          `json:"exam_id"`
	StartTime time.Time      `json:"start_time"`
	Status    ExamStatusEnum `json:"status"`
}

func (q *Queries) CreateExamAttempt(ctx context.Context, arg CreateExamAttemptParams) (ExamAttempt, error) {
	row := q.db.QueryRowContext(ctx, createExamAttempt,
		arg.UserID,
		arg.ExamID,
		arg.StartTime,
		arg.Status,
	)
	var i ExamAttempt
	err := row.Scan(
		&i.AttemptID,
		&i.UserID,
		&i.ExamID,
		&i.StartTime,
		&i.EndTime,
		&i.Score,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteExamAttempt = `-- name: DeleteExamAttempt :exec
DELETE FROM exam_attempts
WHERE attempt_id = $1
`

func (q *Queries) DeleteExamAttempt(ctx context.Context, attemptID int32) error {
	_, err := q.db.ExecContext(ctx, deleteExamAttempt, attemptID)
	return err
}

const getActiveExamAttempt = `-- name: GetActiveExamAttempt :one
SELECT attempt_id, user_id, exam_id, start_time, end_time, score, status, created_at, updated_at FROM exam_attempts
WHERE user_id = $1 AND exam_id = $2 AND status = 'in_progress'
ORDER BY start_time DESC
LIMIT 1
`

type GetActiveExamAttemptParams struct {
	UserID int32 `json:"user_id"`
	ExamID int32 `json:"exam_id"`
}

func (q *Queries) GetActiveExamAttempt(ctx context.Context, arg GetActiveExamAttemptParams) (ExamAttempt, error) {
	row := q.db.QueryRowContext(ctx, getActiveExamAttempt, arg.UserID, arg.ExamID)
	var i ExamAttempt
	err := row.Scan(
		&i.AttemptID,
		&i.UserID,
		&i.ExamID,
		&i.StartTime,
		&i.EndTime,
		&i.Score,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExamAttempt = `-- name: GetExamAttempt :one
SELECT attempt_id, user_id, exam_id, start_time, end_time, score, status, created_at, updated_at FROM exam_attempts
WHERE attempt_id = $1 LIMIT 1
`

func (q *Queries) GetExamAttempt(ctx context.Context, attemptID int32) (ExamAttempt, error) {
	row := q.db.QueryRowContext(ctx, getExamAttempt, attemptID)
	var i ExamAttempt
	err := row.Scan(
		&i.AttemptID,
		&i.UserID,
		&i.ExamID,
		&i.StartTime,
		&i.EndTime,
		&i.Score,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExamAttemptByUser = `-- name: GetExamAttemptByUser :one
SELECT attempt_id, user_id, exam_id, start_time, end_time, score, status, created_at, updated_at FROM exam_attempts
WHERE attempt_id = $1 AND user_id = $2 LIMIT 1
`

type GetExamAttemptByUserParams struct {
	AttemptID int32 `json:"attempt_id"`
	UserID    int32 `json:"user_id"`
}

func (q *Queries) GetExamAttemptByUser(ctx context.Context, arg GetExamAttemptByUserParams) (ExamAttempt, error) {
	row := q.db.QueryRowContext(ctx, getExamAttemptByUser, arg.AttemptID, arg.UserID)
	var i ExamAttempt
	err := row.Scan(
		&i.AttemptID,
		&i.UserID,
		&i.ExamID,
		&i.StartTime,
		&i.EndTime,
		&i.Score,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getExamAttemptStats = `-- name: GetExamAttemptStats :one
SELECT 
    COUNT(*) as total_attempts,
    COUNT(CASE WHEN status = 'completed' THEN 1 END) as completed_attempts,
    COUNT(CASE WHEN status = 'in_progress' THEN 1 END) as in_progress_attempts,
    COUNT(CASE WHEN status = 'abandoned' THEN 1 END) as abandoned_attempts,
    AVG(score) as average_score,
    MAX(score) as highest_score,
    MIN(score) as lowest_score
FROM exam_attempts
WHERE user_id = $1
`

type GetExamAttemptStatsRow struct {
	TotalAttempts      int64       `json:"total_attempts"`
	CompletedAttempts  int64       `json:"completed_attempts"`
	InProgressAttempts int64       `json:"in_progress_attempts"`
	AbandonedAttempts  int64       `json:"abandoned_attempts"`
	AverageScore       float64     `json:"average_score"`
	HighestScore       interface{} `json:"highest_score"`
	LowestScore        interface{} `json:"lowest_score"`
}

func (q *Queries) GetExamAttemptStats(ctx context.Context, userID int32) (GetExamAttemptStatsRow, error) {
	row := q.db.QueryRowContext(ctx, getExamAttemptStats, userID)
	var i GetExamAttemptStatsRow
	err := row.Scan(
		&i.TotalAttempts,
		&i.CompletedAttempts,
		&i.InProgressAttempts,
		&i.AbandonedAttempts,
		&i.AverageScore,
		&i.HighestScore,
		&i.LowestScore,
	)
	return i, err
}

const getExamLeaderboard = `-- name: GetExamLeaderboard :many
SELECT 
    ea.user_id,
    u.username,
    ea.score,
    ea.end_time,
    ROW_NUMBER() OVER (ORDER BY ea.score DESC, ea.end_time ASC) as rank
FROM exam_attempts ea
JOIN users u ON ea.user_id = u.id
WHERE ea.exam_id = $1 AND ea.status = 'completed' AND ea.score IS NOT NULL
ORDER BY ea.score DESC, ea.end_time ASC
LIMIT $2 OFFSET $3
`

type GetExamLeaderboardParams struct {
	ExamID int32 `json:"exam_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type GetExamLeaderboardRow struct {
	UserID   int32          `json:"user_id"`
	Username string         `json:"username"`
	Score    sql.NullString `json:"score"`
	EndTime  sql.NullTime   `json:"end_time"`
	Rank     int64          `json:"rank"`
}

func (q *Queries) GetExamLeaderboard(ctx context.Context, arg GetExamLeaderboardParams) ([]GetExamLeaderboardRow, error) {
	rows, err := q.db.QueryContext(ctx, getExamLeaderboard, arg.ExamID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetExamLeaderboardRow
	for rows.Next() {
		var i GetExamLeaderboardRow
		if err := rows.Scan(
			&i.UserID,
			&i.Username,
			&i.Score,
			&i.EndTime,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExamAttemptsByExam = `-- name: ListExamAttemptsByExam :many
SELECT attempt_id, user_id, exam_id, start_time, end_time, score, status, created_at, updated_at FROM exam_attempts
WHERE exam_id = $1
ORDER BY start_time DESC
LIMIT $2 OFFSET $3
`

type ListExamAttemptsByExamParams struct {
	ExamID int32 `json:"exam_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListExamAttemptsByExam(ctx context.Context, arg ListExamAttemptsByExamParams) ([]ExamAttempt, error) {
	rows, err := q.db.QueryContext(ctx, listExamAttemptsByExam, arg.ExamID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExamAttempt
	for rows.Next() {
		var i ExamAttempt
		if err := rows.Scan(
			&i.AttemptID,
			&i.UserID,
			&i.ExamID,
			&i.StartTime,
			&i.EndTime,
			&i.Score,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listExamAttemptsByUser = `-- name: ListExamAttemptsByUser :many
SELECT attempt_id, user_id, exam_id, start_time, end_time, score, status, created_at, updated_at FROM exam_attempts
WHERE user_id = $1
ORDER BY start_time DESC
LIMIT $2 OFFSET $3
`

type ListExamAttemptsByUserParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListExamAttemptsByUser(ctx context.Context, arg ListExamAttemptsByUserParams) ([]ExamAttempt, error) {
	rows, err := q.db.QueryContext(ctx, listExamAttemptsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ExamAttempt
	for rows.Next() {
		var i ExamAttempt
		if err := rows.Scan(
			&i.AttemptID,
			&i.UserID,
			&i.ExamID,
			&i.StartTime,
			&i.EndTime,
			&i.Score,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateExamAttemptScore = `-- name: UpdateExamAttemptScore :one
UPDATE exam_attempts
SET 
    score = $2,
    status = CASE 
        WHEN $2 IS NOT NULL THEN 'completed'::exam_status_enum
        ELSE status 
    END,
    end_time = CASE 
        WHEN $2 IS NOT NULL AND end_time IS NULL THEN NOW() 
        ELSE end_time 
    END,
    updated_at = NOW()
WHERE attempt_id = $1
RETURNING attempt_id, user_id, exam_id, start_time, end_time, score, status, created_at, updated_at
`

type UpdateExamAttemptScoreParams struct {
	AttemptID int32          `json:"attempt_id"`
	Score     sql.NullString `json:"score"`
}

func (q *Queries) UpdateExamAttemptScore(ctx context.Context, arg UpdateExamAttemptScoreParams) (ExamAttempt, error) {
	row := q.db.QueryRowContext(ctx, updateExamAttemptScore, arg.AttemptID, arg.Score)
	var i ExamAttempt
	err := row.Scan(
		&i.AttemptID,
		&i.UserID,
		&i.ExamID,
		&i.StartTime,
		&i.EndTime,
		&i.Score,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateExamAttemptStatus = `-- name: UpdateExamAttemptStatus :one
UPDATE exam_attempts
SET 
    status = $2,
    end_time = CASE 
        WHEN $2 IN ('completed', 'abandoned') THEN NOW() 
        ELSE end_time 
    END,
    updated_at = NOW()
WHERE attempt_id = $1
RETURNING attempt_id, user_id, exam_id, start_time, end_time, score, status, created_at, updated_at
`

type UpdateExamAttemptStatusParams struct {
	AttemptID int32          `json:"attempt_id"`
	Status    ExamStatusEnum `json:"status"`
}

func (q *Queries) UpdateExamAttemptStatus(ctx context.Context, arg UpdateExamAttemptStatusParams) (ExamAttempt, error) {
	row := q.db.QueryRowContext(ctx, updateExamAttemptStatus, arg.AttemptID, arg.Status)
	var i ExamAttempt
	err := row.Scan(
		&i.AttemptID,
		&i.UserID,
		&i.ExamID,
		&i.StartTime,
		&i.EndTime,
		&i.Score,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
